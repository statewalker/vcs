# Diff/Merge Specification
## Fossil-like Binary Delta Format

```typescript

export type DeltaRange =
  | { from: "source"; start: number; len: number }
  | { from: "target"; start: number; len: number };

export function* createFossilLikeDelta(
  source: Uint8Array,
  target: Uint8Array,
  blockSize = 16,
  minMatch = 16
): Generator<DeltaRange> {
  if (blockSize < 1) {
    throw new Error("blockSize must be >= 1");
  }

  const sourceLen = source.length;
  const targetLen = target.length;

  if (sourceLen === 0 || targetLen === 0) {
    if (targetLen > 0) {
      yield { from: "target", start: 0, len: targetLen };
    }
    return;
  }

  // Rolling hash base
  const BASE = 257 >>> 0;

  // Precompute BASE^(blockSize-1)
  let basePow = 1 >>> 0;
  for (let i = 1; i < blockSize; i++) {
    basePow = (basePow * BASE) >>> 0;
  }

  const computeHash = (buf: Uint8Array, offset: number, len: number): number => {
    let h = 0 >>> 0;
    for (let i = offset, end = offset + len; i < end; i++) {
      h = ((h * BASE) + buf[i]) >>> 0;
    }
    return h >>> 0;
  };

  // ---- Build the rolling-hash index of source ----
  const index = new Map<number, number[]>();
  if (sourceLen >= blockSize) {
    let h = computeHash(source, 0, blockSize);
    index.set(h, [0]);

    for (let i = 1; i <= sourceLen - blockSize; i++) {
      const outByte = source[i - 1];
      const inByte = source[i + blockSize - 1];

      h = (h - ((outByte * basePow) >>> 0)) >>> 0;
      h = (h * BASE) >>> 0;
      h = (h + inByte) >>> 0;

      const arr = index.get(h);
      if (arr) arr.push(i);
      else index.set(h, [i]);
    }
  }

  // ---- emitRange generator ----
  let lastRange: DeltaRange | null = null;

  function* emitRange(range: DeltaRange): Generator<DeltaRange> {
    if (lastRange &&
        lastRange.from === range.from &&
        lastRange.start + lastRange.len === range.start) {
      // merge in-place
      lastRange.len += range.len;
    } else {
      if (lastRange) {
        yield lastRange;
      }
      lastRange = { ...range };
    }
  }

  // ---- Scan target ----
  let lastLiteralStart = 0;
  let t = 0;

  while (t < targetLen) {
    const remaining = targetLen - t;

    if (remaining >= blockSize && sourceLen >= blockSize) {
      const h = computeHash(target, t, blockSize);
      const candidates = index.get(h);

      let bestLen = 0;
      let bestSourcePos = -1;
      let bestTargetPos = t;

      if (candidates) {
        for (const s0 of candidates) {
          let s = s0;
          let tt = t;

          // extend backward
          while (s > 0 && tt > 0 && source[s - 1] === target[tt - 1]) {
            s--; tt--;
          }

          // extend forward
          let L = 0;
          const max = Math.min(sourceLen - s, targetLen - tt);
          while (L < max && source[s + L] === target[tt + L]) {
            L++;
          }

          if (L > bestLen) {
            bestLen = L;
            bestSourcePos = s;
            bestTargetPos = tt;
          }
        }
      }

      if (bestLen >= minMatch) {
        // flush literal before match
        if (bestTargetPos > lastLiteralStart) {
          yield* emitRange({
            from: "target",
            start: lastLiteralStart,
            len: bestTargetPos - lastLiteralStart,
          });
        }

        // emit copy block
        yield* emitRange({
          from: "source",
          start: bestSourcePos,
          len: bestLen,
        });

        const newT = bestTargetPos + bestLen;
        t = newT;
        lastLiteralStart = newT;
        continue;
      }
    }

    // no match â†’ literal byte
    t++;
  }

  // tail literal
  if (lastLiteralStart < targetLen) {
    yield* emitRange({
      from: "target",
      start: lastLiteralStart,
      len: targetLen - lastLiteralStart,
    });
  }

  // flush final pending range
  if (lastRange) {
    yield lastRange;
  }
}
  
```