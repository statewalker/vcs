# Brainstorming Session Results

**Session Date:** 2026-01-30
**Facilitator:** Business Analyst (Mary)
**Topic:** VCS Architecture Evolution

---

## Executive Summary

**Topic:** Clarifying future VCS architecture, APIs, project layout, migration plan, and test coverage

**Session Goals:**
1. Clarify architecture of the future VCS implementation
2. Define APIs
3. Clarify project layout - how APIs and implementations are organized
4. Provide a clear and detailed migration plan
5. Ensure test coverage for all important architectural aspects

**Constraints Identified:**
- Platform-independent (WinterTC APIs only) - browser + server (node, deno, bun)
- FilesAPI (`@statewalker/webrun-files`) for filesystem abstraction
- SQL abstraction layer for database storage
- **Strong requirement:** Remove redundancies - each concept/algorithm/structure defined ONCE
- Prefer reusing existing code, but can change if necessary

**Approach:** Progressive Flow (broad â†’ narrow â†’ converge)

**Techniques Used:**
- Current State Audit (what's working, what's not)
- Gap Analysis (missing components, architectural questions)
- API Definition & Package Layout Design
- Migration Planning (phased approach with dependencies)
- Test Strategy Development

**Total Ideas Generated:**
- 4 concrete redundancies identified and action-planned
- 4 priority NEW components defined
- 6 implementation layers documented
- 5 migration phases with 50+ specific tasks
- Dual-path storage strategy (Git-compatible vs Native SQL/KV)

**Key Themes Identified:**
- Storage abstraction (`RawStorage`) as the critical backend boundary
- Common `ObjectStorage<V>` base interface for Blobs, Trees, Commits, Tags
- Dual-path strategy for structured objects (GitObjects vs native implementations)
- Three-part architecture validation (History / Worktree / Checkout)
- Interface-first design with conformance testing
- Consistent method naming: store, load, has, remove, keys (not delete)

---

## Phase 1: Current State Audit

### 1.1 What's Working Well (Preserve)

| Component | Why It Works | Notes |
|-----------|--------------|-------|
| **Core Stores** (Blob, Tree, Commit, Tag) | Clean separation of history-management from persistence | Keep as foundation |
| **Alternative access patterns** | SerializationAPI (transport) + DeltaAPI (GC) expose internals differently | Implementation-independent GC, git-compatible I/O |
| **GitObjects** | File-based git-compatible implementation | Basis for all *Store implementations |
| **Transport layer independence** | Copied from JGit, basically independent from core | Some mess/redundancy in connectors |
| **Layered architecture** | Independent store implementations | Global layering concept |
| **Command-based Porcelain API** | From JGit | Clean high-level interface |
| **Battle-tested algorithms** | Copied from JGit with unit tests | Proven reliability |

### 1.2 Identified Redundancies

| Area | Description | Impact |
|------|-------------|--------|
| **Store Wrappers** | Multiple wrappers: HistoryStore, StorageBackend, Git, ... | Confusion about which to use, duplicated logic |
| **Delta/Pack handling** | Multiple places dealing with delta/packs | Code duplication, inconsistent behavior risk |
| **Serialization** | Multiple places serializing/deserializing git binary format (blobs, trees, commits, tags) | Maintenance burden, potential inconsistencies |
| **Transport storage abstraction** | Introduces additional storage layer that's redundant | Unnecessary complexity |

### 1.3 Current Store Interface Pattern

Store interfaces are **conceptually independent** but share similar operations:
- `store()` / `load()` / `has()` / `keys()` / `delete()`
- Each adds type-specific methods on top

### 1.4 Concrete Redundancies Found (Code Analysis)

#### A) Delta Binary Parsing - **3 IMPLEMENTATIONS** (Critical)
| Location | Function | Status |
|----------|----------|--------|
| `packages/utils/src/diff/delta/git-delta-format.ts` | `parseGitDelta()` | **MASTER** - keep |
| `packages/core/src/storage/pack/pack-reader.ts:505-570` | `applyDelta()` | **DUPLICATE** - inline parsing |
| `packages/core/src/storage/pack/delta-instruction-analyzer.ts:19-90` | `analyzeDelta()` | **DUPLICATE** - inline parsing |

**Action:** Refactor to use `parseGitDelta()` from utils everywhere.

#### B) Varint Encoding - **4 LOCATIONS**
| Location | Notes |
|----------|-------|
| `packages/utils/src/diff/delta/git-delta-format.ts` | `writeVarint()`, inline parsing |
| `packages/core/src/storage/pack/pack-reader.ts` | Inlined varint parsing |
| `packages/core/src/storage/pack/pack-entries-parser.ts` | Inlined varint parsing |
| `packages/core/src/storage/pack/varint.ts` | **Dedicated module** - should be the source |

**Action:** Centralize all varint operations to `varint.ts`.

#### C) Store Wrapper Redundancies
| Issue | Components | Recommendation |
|-------|------------|----------------|
| Duplicate grouping | `GitStores` â‰ˆ `StructuredStores` | Merge into one |
| Method duplication | `CheckoutStore` methods in `WorkingCopy` | Delegate, don't duplicate |
| Parallel implementations | `GitFilesStorageBackend` / `MemoryStorageBackend` | Extract shared base |

#### D) Serialization - Well-Structured (Minor Issues)
| Layer | Component | Status |
|-------|-----------|--------|
| Header | `object-header.ts` | Clean - handles loose format |
| Content | `commit-format.ts`, `tree-format.ts`, `tag-format.ts` | Clean separation |
| Pack | `pack-entries-parser.ts` | Different format (varint) - not redundant |
| Size computation | `computeCommitSize()`, `computeTreeSize()`, `computeTagSize()` | **Minor redundancy** - similar pattern |

### 1.5 Action Plans for Redundancy Removal

#### Action A: Centralize Delta Parsing
| Step | Task | Files |
|------|------|-------|
| A1 | Keep `parseGitDelta()` in `packages/utils/src/diff/delta/git-delta-format.ts` as master | - |
| A2 | Refactor `pack-reader.ts:applyDelta()` to use master | `packages/core/src/storage/pack/pack-reader.ts` |
| A3 | Refactor `delta-instruction-analyzer.ts:analyzeDelta()` to use master | `packages/core/src/storage/pack/delta-instruction-analyzer.ts` |
| A4 | Add tests verifying consistent behavior | `packages/core/src/storage/pack/__tests__/` |

#### Action B: Centralize Varint Operations
| Step | Task | Files |
|------|------|-------|
| B1 | Move all varint functions to `packages/core/src/storage/pack/varint.ts` | - |
| B2 | Export from `packages/utils` if needed by delta format | `packages/utils/src/diff/delta/` |
| B3 | Replace inline implementations | 3 files |

#### Action C: Consolidate Store Wrappers
| Step | Task | Files |
|------|------|-------|
| C1 | Merge `GitStores` and `StructuredStores` into single interface | `history-store.ts`, `structured-stores.ts` |
| C2 | Make `WorkingCopy` delegate to `CheckoutStore` (not duplicate) | `working-copy.ts` |
| C3 | Extract shared base for storage backends (optional) | `storage-backend.ts` |

---

## Phase 2: Gap Analysis

### 2.1 Confirmed Priority NEW Components

| Component | Priority | Rationale |
|-----------|----------|-----------|
| **GitPackStore** | ğŸ”´ High | Clean implementation required for git-compatible file-based repositories |
| **ChunkedStore** | ğŸ”´ High | Essential for SQL/KV backends - enables large blob handling |
| **TransformationStore** | ğŸ”´ High | Critical for merge/rebase/cherry-pick operations |
| **ResolutionStore** | ğŸ”´ High | Critical for conflict resolution workflow |

### 2.2 Three-Part Architecture - Confirmed Correct

The split is validated:
- **History** - immutable shared history (Part 1)
- **Checkout** - mutable local state (HEAD, staging, operations) (Part 3)
- **Worktree** - filesystem abstraction (Part 2)

### 2.3 Architectural Questions - ANSWERED

#### Question 1: DeltaAPI and Garbage Collection âœ…

**Finding:** Well-designed multi-level decision hierarchy

```
Level 1: OnBlob Tracking
  â””â”€â†’ GCController.onBlob(blobId) - automatic tracking

Level 2: Quick Pack (automatic)
  â””â”€â†’ pendingBlobs >= 5 triggers quickPack()
  â””â”€â†’ DeltaEngine decides compression strategy

Level 3: Full GC (manual)
  â””â”€â†’ Application must call maybeRunGC() periodically
  â””â”€â†’ Checks thresholds: time since last GC, loose blob count, chain depth

Level 4: Explicit GC
  â””â”€â†’ gc.runGC() - forces full repack
```

**Who decides what:**
- **GCController**: WHEN to deltify (scheduling)
- **DeltaEngine**: WHAT to deltify (compression decision)
- **DeltaApi**: HOW to store deltas (storage abstraction)

**Issue:** No automatic full GC - application must call `maybeRunGC()` periodically.

#### Question 2: SerializationAPI and Transport âœ…

**Finding:** SerializationAPI IS the right abstraction - transport exclusively uses it.

**Data Flow:**
```
Transport FSM (negotiation: wants/haves)
    â†“
RepositoryFacade.exportPack(wants, haves)
    â†“
SerializationAPI.createPack(objectIds)
    â†“
Pack bytes (streaming AsyncIterable<Uint8Array>)
    â†“
Transport sends over wire
```

**Key insight:** Transport layer is completely agnostic to pack implementation:
- Never touches delta algorithms
- Never touches pack format directly
- All operations go through RepositoryFacade â†’ SerializationAPI

**Minor issues found:**
1. `RepositoryAccess` vs `RepositoryFacade` - two similar interfaces, one appears unused/legacy
2. Object collection in RepositoryFacade should be delegated to store API

### 2.4 Architecture Layers - Validated

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Transport Layer (protocol-independent)                         â”‚
â”‚  FSM handlers, wire protocol, negotiation                      â”‚
â”‚  Does NOT access stores directly                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RepositoryFacade (adapter)                                     â”‚
â”‚  exportPack(), importPack(), has(), walkAncestors()           â”‚
â”‚  Composes stores for transport                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SerializationAPI (core)                                        â”‚
â”‚  createPack(), importPack(), createPackBuilder()              â”‚
â”‚  Git wire format encoding/decoding                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Core Interfaces                                                â”‚
â”‚  Blobs, Trees, Commits, Tags, Refs                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Conclusion:** Current design is sound. Transport is truly independent from core implementation through SerializationAPI abstraction.

---

## Phase 3: API Definition & Project Layout

### 3.1 API Levels (Public Surface)

| Level | API | Purpose | Users |
|-------|-----|---------|-------|
| **Porcelain** | `Git` class + commands | High-level file versioning operations | End-user applications |
| **Core API** | `History` + `Checkout` + `Worktree` | Individual aspect control | Embedding versioning in applications |
| **Store Implementations** | `Git*`, `Memory*`, `Sql*` classes | Different storage strategies | Storage plugin developers |
| **Transport** | Transport + `History` (+`Checkout`?) | Repository synchronization | Sync implementations |

**Use Case Examples:**
- **Full app:** Use `Git` porcelain for complete Git workflow
- **Embed versioning only:** Use `History` alone, manage other aspects manually
- **Working copy integration:** Use `History` + `Checkout` programmatically
- **Sync between repos:** Use Transport + `History`

### 3.1.1 Naming Convention Decision

**Pattern:** Bare concept names for interfaces, descriptive prefixes for implementations

| Interface | Git Impl | Memory Impl | SQL Impl |
|-----------|----------|-------------|----------|
| `History` | `GitHistory` | `MemoryHistory` | - |
| `Checkout` | `GitCheckout` | `MemoryCheckout` | - |
| `Worktree` | `GitWorktree` | `MemoryWorktree` | - |
| `Blobs` | `GitBlobs` | `MemoryBlobs` | `SqlBlobs` |
| `Trees` | `GitTrees` | `MemoryTrees` | `SqlTrees` |
| `Commits` | `GitCommits` | `MemoryCommits` | `SqlCommits` |
| `Tags` | `GitTags` | `MemoryTags` | `SqlTags` |
| `Refs` | `GitRefs` | `MemoryRefs` | `SqlRefs` |
| `Staging` | `GitStaging` | `MemoryStaging` | - |

**Rationale:**
- No `Store` suffix proliferation
- No `I` prefix (not idiomatic TypeScript)
- Implementation names describe *what kind* of implementation
- `Staging` kept instead of `Index` to avoid DB terminology ambiguity

### 3.1.2 Implementation Layering Model

**Key Insight:** Two implementation paths available for SQL/KV backends:
1. **Path A (Git-compatible):** Use `ChunkedRawStorage` + `GitObjects` for git wire format compatibility
2. **Path B (Native):** Use native SQL/KV implementations with indexes for advanced query capabilities

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LAYER 5: Facades (Backend-Agnostic)                                      â”‚
â”‚  History, Checkout, Worktree                                            â”‚
â”‚  â†’ Compose lower layers into cohesive APIs                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LAYER 4: Algorithms (Backend-Agnostic)                                   â”‚
â”‚  GC, DeltaEngine, SerializationApi, StatusCalculator                    â”‚
â”‚  â†’ Work with abstract interfaces, NO backend-specific implementations   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LAYER 3: Structured Access                                               â”‚
â”‚                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ Storage-Agnostic Path    â”‚    â”‚ Native SQL/KV Path        â”‚           â”‚
â”‚  â”‚ (Git-compatible format)  â”‚    â”‚ (Backend-optimized)       â”‚           â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚
â”‚  â”‚ Blobs (uses GitObjects)  â”‚    â”‚ SqlTrees (native tables)  â”‚           â”‚
â”‚  â”‚ Trees (uses GitObjects)  â”‚    â”‚ SqlCommits (with indexes) â”‚           â”‚
â”‚  â”‚ Commits (uses GitObjects)â”‚    â”‚ SqlTags (with indexes)    â”‚           â”‚
â”‚  â”‚ Tags (uses GitObjects)   â”‚    â”‚ KvTrees, KvCommits, etc.  â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                                          â”‚
â”‚  Blobs: ALWAYS storage-agnostic (uses RawStorage/ChunkedRawStorage)     â”‚
â”‚  Trees, Commits, Tags: Choice of git-format OR native implementation    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LAYER 2: Object Format (Git-specific, uses RawStorage)                   â”‚
â”‚  GitObjects - stores objects with git headers                           â”‚
â”‚  â†’ Single implementation that works with ANY RawStorage                 â”‚
â”‚  â†’ Used by storage-agnostic path and optionally by native backends     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LAYER 1: Raw Storage (MUST be backend-specific)                          â”‚
â”‚  RawStorage interface - basic byte key-value operations                 â”‚
â”‚  â†’ GitFilesRawStorage, MemoryRawStorage, ChunkedRawStorage              â”‚
â”‚  â†’ ChunkedRawStorage works with any ChunkAccess implementation          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LAYER 0: Chunk Access (Backend-specific for SQL/KV)                      â”‚
â”‚  ChunkAccess interface - chunk-based storage for large blobs            â”‚
â”‚  â†’ SqlChunkAccess, KvChunkAccess                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.1.3 Implementation Matrix (Backend-Specific vs. Agnostic)

| Layer | Component | Backend-Specific? | Implementations |
|-------|-----------|-------------------|-----------------|
| **L0** | `ChunkAccess` | âœ… Yes | `SqlChunkAccess`, `KvChunkAccess` |
| **L1** | `RawStorage` | âœ… Yes | `GitFilesRaw`, `MemoryRaw`, `ChunkedRaw` |
| **L2** | `GitObjects` | âŒ No | Single impl (uses any `RawStorage`) |
| **L2** | Pack handling | âš¡ Git-only | Git format utilities (used by git-files) |
| **L3** | `Blobs` | âŒ No | Single impl (uses `RawStorage`/`ChunkedRawStorage`) |
| **L3** | `Trees` | âš¡ Optional | Storage-agnostic OR `SqlTrees`, `KvTrees` (native) |
| **L3** | `Commits` | âš¡ Optional | Storage-agnostic OR `SqlCommits`, `KvCommits` (native) |
| **L3** | `Tags` | âš¡ Optional | Storage-agnostic OR `SqlTags`, `KvTags` (native) |
| **L3** | `Refs` | âš¡ Partial | `GitFilesRefs` (loose+packed), `KvRefs` |
| **L3** | `Staging` | âš¡ Partial | `GitStaging` (index format), `SimpleStaging` |
| **L4** | `DeltaApi` | âŒ No | `BlockDeltaApi` (storage-agnostic) |
| **L4** | `SerializationApi` | âŒ No | Single impl (uses structured stores) |
| **L4** | GC algorithms | âŒ No | Single impl (uses `DeltaApi`) |
| **L5** | `History` | âŒ No | Single facade (composes lower layers) |
| **L5** | `Checkout` | âŒ No | Single facade |
| **L5** | `Worktree` | âŒ No | Single impl (uses `FilesApi`) |

### 3.1.3.1 Storage Strategy Details

#### Blobs: Always Storage-Agnostic
- Use `RawStorage` abstraction for all backends
- SQL/KV backends use `ChunkedRawStorage` over `ChunkAccess` for large blob support
- Content is binary data - no benefit from native SQL/KV structures

#### Trees, Commits, Tags: Dual-Path Strategy

**Path A: Git-Compatible (via GitObjects)**
- Uses `ChunkedRawStorage` + `GitObjects` class
- Stores objects in git binary format with headers
- Advantages: Git wire format compatibility, simpler implementation
- Use when: Git compatibility is priority, simple use cases

**Path B: Native SQL/KV Implementations**
- Store structured data in native SQL tables or KV collections
- Enable indexes on: author, committer, date ranges, paths, message search
- Advantages:
  - Fossil-like features: `findByAuthor()`, `findByDateRange()`, `searchMessage()`
  - More efficient queries without parsing binary format
  - Better integration with backend-native capabilities
- Use when: Advanced query capabilities needed, performance-critical

**Example Extended Query Interfaces:**
```typescript
// Commits already inherits from ObjectStorage<Commit>:
//   store, load, has, remove, keys

interface CommitsExtended extends Commits {
  // Extended queries (available in native implementations)
  findByAuthor?(author: string): AsyncIterable<ObjectId>;
  findByDateRange?(start: Date, end: Date): AsyncIterable<ObjectId>;
  searchMessage?(pattern: string): AsyncIterable<ObjectId>;
}

// Trees already inherits from ObjectStorage<Tree>:
//   store, load, has, remove, keys

interface TreesExtended extends Trees {
  // Extended queries
  findByPath?(pathPattern: string): AsyncIterable<{ treeId: ObjectId; entry: TreeEntry }>;
}
```

**Implementation Choice per Backend:**
| Backend | Blobs | Trees/Commits/Tags | Rationale |
|---------|-------|-------------------|-----------|
| Git Files | Via `GitObjects` | Via `GitObjects` | Git compatibility required |
| Memory | Via `GitObjects` | Via `GitObjects` | Testing, simplicity |
| SQL | `ChunkedRawStorage` | Native SQL tables | Full query capabilities |
| KV | `ChunkedRawStorage` | Native OR `GitObjects` | Depends on KV capabilities |

### 3.1.4 Core Interface Design

#### Common ObjectStorage Base Interface

Object stores (`Blobs`, `Trees`, `Commits`, `Tags`) share a common base interface for consistency:

```typescript
// Base interface for content-addressed object stores
interface ObjectStorage<V> {
  store(value: V): Promise<ObjectId>;           // Returns computed SHA-1
  load(id: ObjectId): Promise<V | undefined>;   // Returns undefined if not found
  has(id: ObjectId): Promise<boolean>;
  remove(id: ObjectId): Promise<boolean>;       // 'remove' not 'delete' (JS keyword)
  keys(): AsyncIterable<ObjectId>;
}

// Concrete object store interfaces
interface Blobs extends ObjectStorage<Blob> {}
interface Trees extends ObjectStorage<Tree> {}
interface Commits extends ObjectStorage<Commit> {}
interface Tags extends ObjectStorage<Tag> {}
```

**Why a common base:**
- Consistency across all object stores
- Enables generic utilities and decorators (caching, logging, metrics)
- Simplifies conformance testing
- Clear contract for new implementations

**Why `Refs` is separate:**
- Different update semantics (atomic compare-and-swap)
- Symbolic refs vs direct refs
- No content-addressing (key is name, not hash)

#### RawStorage Interface (Byte-Level)

`RawStorage` is separate from `ObjectStorage` due to different semantics:

```typescript
// RawStorage is THE backend boundary
interface RawStorage {
  store(key: string, content: AsyncIterable<Uint8Array>): Promise<void>;
  load(key: string, options?: { start?: number; end?: number }): AsyncIterable<Uint8Array>;
  has(key: string): Promise<boolean>;
  remove(key: string): Promise<boolean>;       // 'remove' not 'delete' (JS keyword)
  keys(): AsyncIterable<string>;
  size(key: string): Promise<number>;
}

// ChunkedRawStorage works with any ChunkAccess
class ChunkedRawStorage implements RawStorage {
  constructor(access: ChunkAccess, chunkSize: number = 1024 * 1024) { ... }
}

// DeltaApi is storage-agnostic - uses abstract RawStorage
class BlockDeltaApi implements DeltaApi {
  constructor(
    private baseStorage: RawStorage,    // for base objects
    private deltaStorage: RawStorage,   // for delta objects
  ) { ... }
}

// Same DeltaApi implementation works with ANY backend!
const gitDelta = new BlockDeltaApi(gitFilesRaw, gitFilesRaw);
const sqlDelta = new BlockDeltaApi(sqlChunkedRaw, sqlChunkedRaw);
const kvDelta = new BlockDeltaApi(kvChunkedRaw, kvChunkedRaw);
```

### 3.1.5 Revised Naming Table (Reflecting Layering)

| Interface | Implementation | Notes |
|-----------|----------------|-------|
| `RawStorage` | `GitFilesRaw`, `MemoryRaw`, `ChunkedRaw` | Backend boundary |
| `ChunkAccess` | `SqlChunkAccess`, `KvChunkAccess` | For SQL/KV only |
| `GitObjects` | Single impl | Uses any `RawStorage`; basis for git-format stores |
| `Blobs` | Single impl | Uses `RawStorage` (or `ChunkedRawStorage` for SQL/KV) |
| `Trees` | Storage-agnostic OR `SqlTrees`, `KvTrees` | Choice: via `GitObjects` or native |
| `Commits` | Storage-agnostic OR `SqlCommits`, `KvCommits` | Choice: via `GitObjects` or native |
| `Tags` | Storage-agnostic OR `SqlTags`, `KvTags` | Choice: via `GitObjects` or native |
| `Refs` | `GitFilesRefs`, `KvRefs` | Different storage patterns |
| `Staging` | `GitStaging`, `SimpleStaging` | Different formats |
| `DeltaApi` | `BlockDeltaApi` | Storage-agnostic |
| `History` | Single facade | Composes stores |
| `Checkout` | Single facade | Composes stores |
| `Worktree` | Single impl | Uses `FilesApi` |

### 3.2 Package Boundaries - Revised

**Move to `packages/utils/`:**
- All delta/diff algorithms (currently split between utils and core)
- Future: May split into separate `packages/diff/` and `packages/delta/`

**Consolidation principle:** Algorithm = utils, Orchestration = core

### 3.3 GitPackStore Location

**Decision:** Group with `GitObjects` interface and implementation

**Rationale:**
- Very git-specific
- Provides git-compatible binary storage basis
- Foundation for `Blobs`, `Trees`, `Commits`, `Tags` (via GitObjects)

**Proposed location:** `packages/core/src/backend/git/objects/` or `packages/core/src/storage/pack/`

```
packages/core/src/
â”œâ”€â”€ backend/
â”‚   â””â”€â”€ git/
â”‚       â””â”€â”€ objects/
â”‚           â”œâ”€â”€ git-objects.ts       # GitObjects class
â”‚           â””â”€â”€ git-pack-store.ts    # NEW: Pack-based storage
â””â”€â”€ storage/
    â””â”€â”€ pack/                        # Pack format utilities (reader, writer, etc.)
```

### 3.4 ChunkedStore Location

**Decision:** Abstract class in core with data access interface

**Rationale:**
- Common implementation pattern for SQL/KV stores
- ~1MB chunks for efficient large blob handling
- Concrete class using abstract data access interface

**Proposed structure:**
```typescript
// packages/core/src/storage/chunked/chunked-storage.ts
interface ChunkAccess {
  storeChunk(key: string, index: number, data: Uint8Array): Promise<void>;
  loadChunk(key: string, index: number): Promise<Uint8Array>;
  getChunkCount(key: string): Promise<number>;
  removeChunks(key: string): Promise<void>;   // 'remove' not 'delete'
}

class ChunkedRawStorage implements RawStorage {
  constructor(private access: ChunkAccess, private chunkSize: number = 1024 * 1024) {}
  // ... implements RawStorage using chunks
}
```

**Location:** `packages/core/src/storage/chunked/`

### 3.5 Proposed Package Structure (REVISED)

```
packages/
â”‚
â”œâ”€â”€ utils/                              # Pure algorithms (no I/O dependencies)
â”‚   â”œâ”€â”€ diff/                           # Diff algorithms
â”‚   â”‚   â”œâ”€â”€ delta/                      # Delta compression (ALL moved here)
â”‚   â”‚   â”‚   â”œâ”€â”€ git-delta-format.ts     # Git binary delta format
â”‚   â”‚   â”‚   â”œâ”€â”€ create-delta-ranges.ts  # Rolling hash algorithm
â”‚   â”‚   â”‚   â”œâ”€â”€ apply-delta.ts          # Delta application
â”‚   â”‚   â”‚   â””â”€â”€ varint.ts               # Centralized varint encoding
â”‚   â”‚   â””â”€â”€ text/                       # Text diff (Myers, patience, etc.)
â”‚   â””â”€â”€ streams/                        # Stream utilities
â”‚
â”œâ”€â”€ core/                               # Core abstractions + implementations
â”‚   â”‚
â”‚   â”œâ”€â”€ history/                        # â•â•â•â•â•â• ABSTRACT INTERFACES â•â•â•â•â•â•
â”‚   â”‚   â”œâ”€â”€ history.ts                  # History interface (Part 1)
â”‚   â”‚   â”œâ”€â”€ blobs/                      # Blobs interface
â”‚   â”‚   â”œâ”€â”€ trees/                      # Trees interface
â”‚   â”‚   â”œâ”€â”€ commits/                    # Commits interface
â”‚   â”‚   â”œâ”€â”€ tags/                       # Tags interface
â”‚   â”‚   â””â”€â”€ refs/                       # Refs + Reflog interfaces
â”‚   â”‚
â”‚   â”œâ”€â”€ workspace/                      # â•â•â•â•â•â• WORKSPACE LAYER â•â•â•â•â•â•
â”‚   â”‚   â”œâ”€â”€ checkout/                   # Checkout (Part 3)
â”‚   â”‚   â”‚   â”œâ”€â”€ checkout.ts             #   Interface
â”‚   â”‚   â”‚   â”œâ”€â”€ git-checkout.ts         #   Git file-based impl
â”‚   â”‚   â”‚   â””â”€â”€ memory-checkout.ts      #   Memory impl
â”‚   â”‚   â”œâ”€â”€ staging/                    # Staging (index)
â”‚   â”‚   â”‚   â”œâ”€â”€ staging.ts              #   Interface
â”‚   â”‚   â”‚   â””â”€â”€ git-staging.ts          #   Implementations
â”‚   â”‚   â”œâ”€â”€ worktree/                   # Worktree (Part 2)
â”‚   â”‚   â”‚   â””â”€â”€ worktree.ts             #   Interface + impl
â”‚   â”‚   â”œâ”€â”€ status/                     # StatusCalculator
â”‚   â”‚   â”œâ”€â”€ ignore/                     # IgnoreManager
â”‚   â”‚   â”œâ”€â”€ working-copy/               # WorkingCopy facade
â”‚   â”‚   â””â”€â”€ transformation/             # NEW: MergeState, RebaseState, Sequencer
â”‚   â”‚       â”œâ”€â”€ merge-state-store.ts
â”‚   â”‚       â”œâ”€â”€ rebase-state-store.ts
â”‚   â”‚       â”œâ”€â”€ sequencer-store.ts      # Unified cherry-pick/revert
â”‚   â”‚       â””â”€â”€ resolution-store.ts     # Conflict resolution
â”‚   â”‚
â”‚   â”œâ”€â”€ storage/                        # â•â•â•â•â•â• GENERIC STORAGE â•â•â•â•â•â•
â”‚   â”‚   â”œâ”€â”€ binary/                     # RawStore, VolatileStore
â”‚   â”‚   â”œâ”€â”€ chunked/                    # NEW: ChunkedStore for SQL/KV
â”‚   â”‚   â””â”€â”€ delta/                      # Delta orchestration
â”‚   â”‚       â”œâ”€â”€ delta-engine.ts         #   Compression decision
â”‚   â”‚       â”œâ”€â”€ gc-controller.ts        #   GC scheduling
â”‚   â”‚       â””â”€â”€ delta-api.ts            #   Storage abstraction
â”‚   â”‚
â”‚   â”œâ”€â”€ backend/                        # â•â•â•â•â•â• STORAGE BACKENDS â•â•â•â•â•â•
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ git/                        # Git binary format layer (NEW grouping)
â”‚   â”‚   â”‚   â”œâ”€â”€ objects/                #   GitObjectStore (headers, format)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ object-store.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ object-header.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ git-pack-store.ts   #   NEW: Pack-based object storage
â”‚   â”‚   â”‚   â”œâ”€â”€ pack/                   #   Pack format utilities
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ pack-reader.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ pack-writer.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ pack-index-*.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ pack-entries-parser.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ refs/                   #   Git ref format
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ref-writer.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ packed-refs.ts
â”‚   â”‚   â”‚   â””â”€â”€ format/                 #   Object content formats
â”‚   â”‚   â”‚       â”œâ”€â”€ commit-format.ts
â”‚   â”‚   â”‚       â”œâ”€â”€ tree-format.ts
â”‚   â”‚   â”‚       â””â”€â”€ tag-format.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ git-files/                  # Git file system layout (.git/)
â”‚   â”‚   â”‚   â””â”€â”€ git-files-storage-backend.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ memory/                     # In-memory backend
â”‚   â”‚   â”‚   â””â”€â”€ memory-storage-backend.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ storage-backend.ts          # StorageBackend interface
â”‚   â”‚
â”‚   â””â”€â”€ serialization/                  # SerializationAPI (transport bridge)
â”‚       â”œâ”€â”€ serialization-api.ts
â”‚       â””â”€â”€ serialization-api.impl.ts
â”‚
â”œâ”€â”€ commands/                           # â•â•â•â•â•â• PORCELAIN API â•â•â•â•â•â•
â”‚   â”œâ”€â”€ git.ts                          # Git class (main entry point)
â”‚   â”œâ”€â”€ types.ts                        # GitStore interfaces
â”‚   â”œâ”€â”€ git-command.ts                  # Base command class
â”‚   â”œâ”€â”€ transport-command.ts            # Base for network commands
â”‚   â”œâ”€â”€ commands/                       # Individual command implementations
â”‚   â”‚   â”œâ”€â”€ add-command.ts
â”‚   â”‚   â”œâ”€â”€ commit-command.ts
â”‚   â”‚   â”œâ”€â”€ checkout-command.ts
â”‚   â”‚   â”œâ”€â”€ merge-command.ts
â”‚   â”‚   â”œâ”€â”€ fetch-command.ts
â”‚   â”‚   â”œâ”€â”€ push-command.ts
â”‚   â”‚   â””â”€â”€ ... (50+ commands)
â”‚   â”œâ”€â”€ errors/                         # Command-specific errors
â”‚   â””â”€â”€ results/                        # Command result types
â”‚
â”œâ”€â”€ transport/                          # â•â•â•â•â•â• PROTOCOL LAYER â•â•â•â•â•â•
â”‚   â”œâ”€â”€ api/                            # Transport interfaces
â”‚   â”‚   â”œâ”€â”€ transport-api.ts            #   Wire protocol I/O
â”‚   â”‚   â”œâ”€â”€ repository-facade.ts        #   Repository operations for transport
â”‚   â”‚   â”œâ”€â”€ duplex.ts                   #   Bidirectional stream
â”‚   â”‚   â””â”€â”€ credentials.ts              #   Authentication
â”‚   â”œâ”€â”€ fsm/                            # Finite state machines
â”‚   â”‚   â”œâ”€â”€ fetch/                      #   Fetch protocol FSM
â”‚   â”‚   â”œâ”€â”€ push/                       #   Push protocol FSM
â”‚   â”‚   â”œâ”€â”€ protocol-v2/                #   Git protocol v2
â”‚   â”‚   â””â”€â”€ error-recovery/             #   Error handling
â”‚   â”œâ”€â”€ protocol/                       # Wire format utilities
â”‚   â”‚   â”œâ”€â”€ pkt-line-codec.ts           #   Packet line encoding
â”‚   â”‚   â”œâ”€â”€ sideband.ts                 #   Sideband multiplexing
â”‚   â”‚   â””â”€â”€ capabilities.ts             #   Capability negotiation
â”‚   â”œâ”€â”€ adapters/                       # Transport adapters
â”‚   â”‚   â”œâ”€â”€ http/                       #   HTTP smart protocol
â”‚   â”‚   â”œâ”€â”€ socket/                     #   TCP/SSH
â”‚   â”‚   â””â”€â”€ messageport/                #   Web Worker communication
â”‚   â””â”€â”€ factories/                      # Factory functions
â”‚       â””â”€â”€ repository-facade-factory.ts
â”‚
â”œâ”€â”€ transport-adapters/                 # â•â•â•â•â•â• INTEGRATION ADAPTERS â•â•â•â•â•â•
â”‚   â””â”€â”€ vcs-repository-facade.ts        # Connects transport to VCS stores
â”‚
â”œâ”€â”€ store-sql/                          # â•â•â•â•â•â• SQL STORAGE (separate pkg) â•â•â•â•â•â•
â”‚   â””â”€â”€ (uses ChunkedStore from core)
â”‚
â””â”€â”€ store-kv/                           # â•â•â•â•â•â• KV STORAGE (separate pkg) â•â•â•â•â•â•
    â””â”€â”€ (uses ChunkedStore from core)
```

### 3.6 Layer Dependencies

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         PORCELAIN (packages/commands/)                   â”‚
â”‚   Git class, 50+ commands                                                â”‚
â”‚   Depends on: core (all), transport (for network commands)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼                           â–¼                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    WORKSPACE      â”‚   â”‚     HISTORY       â”‚   â”‚      TRANSPORT        â”‚
â”‚ (core/workspace/) â”‚   â”‚ (core/history/)   â”‚   â”‚ (packages/transport/) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Checkout          â”‚   â”‚ History           â”‚   â”‚ TransportApi          â”‚
â”‚ Worktree          â”‚   â”‚ Blobs             â”‚   â”‚ RepositoryFacade      â”‚
â”‚ Staging           â”‚   â”‚ Trees             â”‚   â”‚ FSM handlers          â”‚
â”‚ StatusCalculator  â”‚   â”‚ Commits           â”‚   â”‚ Protocol utilities    â”‚
â”‚ Transformation    â”‚   â”‚ Tags              â”‚   â”‚                       â”‚
â”‚ Resolution        â”‚   â”‚ Refs              â”‚   â”‚                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                           â”‚                           â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      SERIALIZATION (core/serialization/)                 â”‚
â”‚   SerializationAPI - bridge between stores and transport                â”‚
â”‚   createPack(), importPack(), createPackBuilder()                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         BACKEND (core/backend/)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   backend/git/    â”‚   backend/git-files/      â”‚   backend/memory/       â”‚
â”‚   (format layer)  â”‚   (file layout)           â”‚   (testing)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ GitObjectStore    â”‚ GitFilesStorageBackend    â”‚ MemoryStorageBackend    â”‚
â”‚ GitPackStore      â”‚ .git/ directory layout    â”‚                         â”‚
â”‚ Pack r/w/index    â”‚                           â”‚                         â”‚
â”‚ Object formats    â”‚                           â”‚                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         STORAGE (core/storage/)                          â”‚
â”‚   RawStore, VolatileStore, ChunkedStore, Delta orchestration            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           UTILS (packages/utils/)                        â”‚
â”‚   Pure algorithms: delta, diff, varint, streams                         â”‚
â”‚   No I/O dependencies                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Phase 4: Migration Plan

### 4.1 Migration Principles

1. **Incremental refactoring** - Each step should leave the codebase in a working state
2. **Test-driven** - Write tests before refactoring, ensure they pass after
3. **Interface-first** - Define interfaces before implementations
4. **Clean break** - Remove old implementations completely, no deprecation or backward compatibility shims

### 4.2 Migration Phases

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE A: Foundation (Remove Redundancies)                               â”‚
â”‚ Goal: Single source of truth for algorithms                             â”‚
â”‚ Duration: Independent of other phases                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE B: Storage Abstractions                                           â”‚
â”‚ Goal: Establish clean storage layer boundaries                          â”‚
â”‚ Depends on: Phase A (for varint/delta utils)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE C: Structured Store Migration                                     â”‚
â”‚ Goal: Migrate to new storage architecture                               â”‚
â”‚ Depends on: Phase B (for RawStorage/ChunkAccess)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE D: New Components                                                 â”‚
â”‚ Goal: Add GitPackStore, TransformationStore, ResolutionStore           â”‚
â”‚ Depends on: Phase C (for store interfaces)                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE E: Facade & Package Consolidation                                 â”‚
â”‚ Goal: Clean public APIs, final package structure                        â”‚
â”‚ Depends on: Phases A-D                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### PHASE A: Foundation (Remove Redundancies)

#### A1: Centralize Varint Encoding
**Files:** `packages/utils/src/encoding/varint.ts` (new location)

| Step | Task | Status |
|------|------|--------|
| A1.1 | Create `packages/utils/src/encoding/varint.ts` with all varint functions | â¬œ |
| A1.2 | Export: `readVarint()`, `writeVarint()`, `varintSize()` | â¬œ |
| A1.3 | Update `packages/core/src/storage/pack/varint.ts` to re-export from utils | â¬œ |
| A1.4 | Refactor `git-delta-format.ts` to use centralized varint | â¬œ |
| A1.5 | Refactor `pack-reader.ts` inline varint parsing | â¬œ |
| A1.6 | Refactor `pack-entries-parser.ts` inline varint parsing | â¬œ |
| A1.7 | Add comprehensive varint tests | â¬œ |

#### A2: Centralize Delta Parsing
**Files:** `packages/utils/src/diff/delta/`

| Step | Task | Status |
|------|------|--------|
| A2.1 | Ensure `parseGitDelta()` in `git-delta-format.ts` is the master implementation | â¬œ |
| A2.2 | Extract reusable delta instruction types | â¬œ |
| A2.3 | Refactor `pack-reader.ts:applyDelta()` to use `parseGitDelta()` | â¬œ |
| A2.4 | Refactor `delta-instruction-analyzer.ts:analyzeDelta()` to use `parseGitDelta()` | â¬œ |
| A2.5 | Add integration tests for delta round-trip | â¬œ |

#### A3: Consolidate Size Computation (Minor)
**Files:** `packages/core/src/backend/git/format/`

| Step | Task | Status |
|------|------|--------|
| A3.1 | Extract common size computation pattern | â¬œ |
| A3.2 | Unify `computeCommitSize()`, `computeTreeSize()`, `computeTagSize()` | â¬œ |

---

### PHASE B: Storage Abstractions

#### B1: Define RawStorage Interface
**Files:** `packages/core/src/storage/raw/`

| Step | Task | Status |
|------|------|--------|
| B1.1 | Create `raw-storage.ts` with `RawStorage` interface | â¬œ |
| B1.2 | Define streaming operations: `store()`, `load()`, `has()`, `remove()`, `keys()`, `size()` | â¬œ |
| B1.3 | Create `GitFilesRawStorage` adapter over existing implementation | â¬œ |
| B1.4 | Create `MemoryRawStorage` adapter | â¬œ |
| B1.5 | Add RawStorage interface tests | â¬œ |

#### B2: Define ChunkAccess Interface
**Files:** `packages/core/src/storage/chunked/`

| Step | Task | Status |
|------|------|--------|
| B2.1 | Create `chunk-access.ts` with `ChunkAccess` interface | â¬œ |
| B2.2 | Define operations: `storeChunk()`, `loadChunk()`, `getChunkCount()`, `removeChunks()` | â¬œ |
| B2.3 | Create abstract test suite for ChunkAccess conformance | â¬œ |

#### B3: Implement ChunkedRawStorage
**Files:** `packages/core/src/storage/chunked/`

| Step | Task | Status |
|------|------|--------|
| B3.1 | Create `ChunkedRawStorage` class implementing `RawStorage` | â¬œ |
| B3.2 | Implement chunking logic (~1MB default chunk size) | â¬œ |
| B3.3 | Handle streaming for large blobs | â¬œ |
| B3.4 | Add tests with mock ChunkAccess | â¬œ |

#### B4: Refactor GitObjects to Use RawStorage
**Files:** `packages/core/src/backend/git/objects/`

| Step | Task | Status |
|------|------|--------|
| B4.1 | Refactor `GitObjectStore` constructor to accept `RawStorage` | â¬œ |
| B4.2 | Remove direct file system dependencies from GitObjects | â¬œ |
| B4.3 | Verify existing tests pass | â¬œ |
| B4.4 | Add test with MemoryRawStorage backend | â¬œ |

---

### PHASE C: Structured Store Migration

#### C1: Define Core Store Interfaces
**Files:** `packages/core/src/history/`

| Step | Task | Status |
|------|------|--------|
| C1.1 | Create `blobs.ts` with `Blobs` interface | â¬œ |
| C1.2 | Create `trees.ts` with `Trees` interface (+ optional extended queries) | â¬œ |
| C1.3 | Create `commits.ts` with `Commits` interface (+ optional extended queries) | â¬œ |
| C1.4 | Create `tags.ts` with `Tags` interface (+ optional extended queries) | â¬œ |
| C1.5 | Create `refs.ts` with `Refs` interface | â¬œ |
| C1.6 | Ensure all interfaces use `AsyncIterable` for streaming | â¬œ |

#### C2: Implement Storage-Agnostic Stores
**Files:** `packages/core/src/history/impl/`

| Step | Task | Status |
|------|------|--------|
| C2.1 | Implement `Blobs` using `RawStorage` (not `GitObjects`) | â¬œ |
| C2.2 | Implement `Trees` using `GitObjects` | â¬œ |
| C2.3 | Implement `Commits` using `GitObjects` | â¬œ |
| C2.4 | Implement `Tags` using `GitObjects` | â¬œ |
| C2.5 | Migrate existing store tests to new implementations | â¬œ |

#### C3: Create History Facade
**Files:** `packages/core/src/history/`

| Step | Task | Status |
|------|------|--------|
| C3.1 | Create `History` interface (Part 1 of three-part architecture) | â¬œ |
| C3.2 | Implement `History` facade composing Blobs, Trees, Commits, Tags, Refs | â¬œ |
| C3.3 | Add factory functions for different backend configurations | â¬œ |

#### C4: Migrate Workspace Components
**Files:** `packages/core/src/workspace/`

| Step | Task | Status |
|------|------|--------|
| C4.1 | Create `Staging` interface (replacing Index) | â¬œ |
| C4.2 | Create `GitStaging` implementation (git index format) | â¬œ |
| C4.3 | Create `SimpleStaging` implementation (KV-based) | â¬œ |
| C4.4 | Create `Checkout` interface (Part 3 of three-part architecture) | â¬œ |
| C4.5 | Create `Worktree` interface (Part 2 of three-part architecture) | â¬œ |
| C4.6 | Refactor `WorkingCopy` to delegate to `CheckoutStore` (not duplicate) | â¬œ |

#### C5: Consolidate Store Wrappers
**Files:** `packages/core/src/`

| Step | Task | Status |
|------|------|--------|
| C5.1 | Identify all store wrapper classes (HistoryStore, StorageBackend, Git, etc.) | â¬œ |
| C5.2 | Merge overlapping wrappers into single interfaces | â¬œ |
| C5.3 | Update all consumers to use consolidated interfaces | â¬œ |
| C5.4 | Remove deprecated wrapper classes | â¬œ |

---

### PHASE D: New Components

#### D1: Implement GitPackStore
**Files:** `packages/core/src/backend/git/objects/`

| Step | Task | Status |
|------|------|--------|
| D1.1 | Design GitPackStore interface (pack-based object storage) | â¬œ |
| D1.2 | Implement pack file reading (leverage existing pack-reader) | â¬œ |
| D1.3 | Implement pack file writing (leverage existing pack-writer) | â¬œ |
| D1.4 | Implement pack index management | â¬œ |
| D1.5 | Add comprehensive tests | â¬œ |

#### D2: Implement TransformationStore
**Files:** `packages/core/src/workspace/transformation/`

| Step | Task | Status |
|------|------|--------|
| D2.1 | Design state storage interfaces (MergeState, RebaseState, etc.) | â¬œ |
| D2.2 | Implement `MergeStateStore` (tracks merge in progress) | â¬œ |
| D2.3 | Implement `RebaseStateStore` (tracks rebase in progress) | â¬œ |
| D2.4 | Implement `SequencerStore` (unified cherry-pick/revert) | â¬œ |
| D2.5 | Add tests for state persistence and recovery | â¬œ |

#### D3: Implement ResolutionStore
**Files:** `packages/core/src/workspace/transformation/`

| Step | Task | Status |
|------|------|--------|
| D3.1 | Design conflict resolution interface | â¬œ |
| D3.2 | Implement conflict tracking (which files, what type) | â¬œ |
| D3.3 | Implement resolution recording (how conflicts were resolved) | â¬œ |
| D3.4 | Integrate with TransformationStore | â¬œ |
| D3.5 | Add tests for conflict resolution workflows | â¬œ |

#### D4: Implement SQL/KV Native Stores (Optional)
**Files:** `packages/store-sql/`, `packages/store-kv/`

| Step | Task | Status |
|------|------|--------|
| D4.1 | Create `SqlChunkAccess` implementation | â¬œ |
| D4.2 | Create `SqlTrees` with native table storage + indexes | â¬œ |
| D4.3 | Create `SqlCommits` with author/date indexes | â¬œ |
| D4.4 | Create `SqlTags` with native storage | â¬œ |
| D4.5 | Add extended query tests | â¬œ |
| D4.6 | Create KV equivalents if needed | â¬œ |

---

### PHASE E: Facade & Package Consolidation

#### E1: Finalize Public API
**Files:** `packages/commands/`

| Step | Task | Status |
|------|------|--------|
| E1.1 | Ensure `Git` class uses new facades (History, Checkout, Worktree) | â¬œ |
| E1.2 | Update all commands to use new store interfaces | â¬œ |
| E1.3 | Verify backward compatibility of porcelain API | â¬œ |

#### E2: Refactor SerializationAPI
**Files:** `packages/core/src/serialization/`

| Step | Task | Status |
|------|------|--------|
| E2.1 | Ensure SerializationAPI uses new store interfaces | â¬œ |
| E2.2 | Clean up RepositoryFacade vs RepositoryAccess duplication | â¬œ |
| E2.3 | Verify transport layer integration | â¬œ |

#### E3: Package Structure Reorganization
**Files:** All packages

| Step | Task | Status |
|------|------|--------|
| E3.1 | Move delta/diff algorithms to `packages/utils/` | â¬œ |
| E3.2 | Organize `packages/core/` per proposed structure | â¬œ |
| E3.3 | Update all import paths | â¬œ |
| E3.4 | Update package.json exports | â¬œ |
| E3.5 | Verify all tests pass | â¬œ |

#### E4: Documentation & Cleanup
**Files:** Documentation

| Step | Task | Status |
|------|------|--------|
| E4.1 | Update architecture documentation | â¬œ |
| E4.2 | Document public API usage examples | â¬œ |
| E4.3 | Remove deprecated code | â¬œ |
| E4.4 | Final cleanup and linting | â¬œ |

---

### 4.3 Migration Dependencies Graph

```
A1 (varint) â”€â”€â”€â”€â”¬â”€â”€â–º A2 (delta) â”€â”€â”€â”
                â”‚                   â”‚
A3 (size) â”€â”€â”€â”€â”€â”€â”˜                   â”‚
                                    â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
B1 (RawStorage) â”€â”€â–º B4 (GitObjects refactor)
        â”‚
        â–¼
B2 (ChunkAccess) â”€â”€â–º B3 (ChunkedRawStorage)
        â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                           â”‚
                           â–¼
            C1 (Store interfaces) â”€â”€â–º C2 (Implementations)
                           â”‚                   â”‚
                           â”‚                   â–¼
                           â”‚          C3 (History facade)
                           â”‚                   â”‚
                           â–¼                   â”‚
                    C4 (Workspace) â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
                    C5 (Consolidation)
                           â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                  â”‚                  â”‚
        â–¼                  â–¼                  â–¼
D1 (GitPackStore)  D2 (Transform)   D4 (SQL/KV native)
        â”‚                  â”‚
        â”‚                  â–¼
        â”‚          D3 (Resolution)
        â”‚                  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
        E1 (Public API) â”€â”€â–º E2 (SerializationAPI)
                  â”‚
                  â–¼
        E3 (Package reorg) â”€â”€â–º E4 (Documentation)
```

### 4.4 Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Breaking existing tests | Run full test suite after each step |
| Import path changes breaking consumers | Use barrel exports, update incrementally |
| Performance regression | Benchmark critical paths before/after |
| Incomplete migration | Track completion status per step |
| Missing edge cases | Add tests before refactoring |

---

## Phase 5: Test Strategy

### 5.1 Testing Principles

1. **Interface-based testing** - Tests should verify interface contracts, not implementation details
2. **Backend-agnostic tests** - Core store tests should run against all backend implementations
3. **Conformance test suites** - Shared test suites that any implementation must pass
4. **Integration before unit** - Prioritize integration tests for cross-component behavior

### 5.2 Test Categories

#### Category A: Interface Conformance Tests

**Purpose:** Verify any implementation of an interface behaves correctly.

| Interface | Test Suite | Implementations to Test |
|-----------|------------|------------------------|
| `RawStorage` | `raw-storage.conformance.test.ts` | `GitFilesRaw`, `MemoryRaw`, `ChunkedRaw` |
| `ChunkAccess` | `chunk-access.conformance.test.ts` | `SqlChunkAccess`, `KvChunkAccess`, `MemoryChunkAccess` |
| `ObjectStorage<V>` | `object-storage.conformance.test.ts` | Base test for all object stores |
| `Blobs` | `blobs.conformance.test.ts` | Storage-agnostic impl |
| `Trees` | `trees.conformance.test.ts` | Storage-agnostic, `SqlTrees`, `KvTrees` |
| `Commits` | `commits.conformance.test.ts` | Storage-agnostic, `SqlCommits`, `KvCommits` |
| `Tags` | `tags.conformance.test.ts` | Storage-agnostic, `SqlTags`, `KvTags` |
| `Refs` | `refs.conformance.test.ts` | `GitFilesRefs`, `KvRefs` |
| `Staging` | `staging.conformance.test.ts` | `GitStaging`, `SimpleStaging` |

**Note:** `Blobs`, `Trees`, `Commits`, `Tags` all extend `ObjectStorage<V>`, so they share:
- Base conformance tests (store, load, has, remove, keys)
- Type-specific tests (blob streaming, tree entries, commit parents, etc.)

**Test Pattern:**
```typescript
// Base ObjectStorage conformance (shared by all object stores)
// packages/core/src/history/__tests__/object-storage.conformance.ts
export function objectStorageConformanceTests<V>(
  name: string,
  createStore: () => Promise<ObjectStorage<V>>,
  createValue: () => V,
  cleanup: () => Promise<void>
) {
  describe(`${name} ObjectStorage conformance`, () => {
    let store: ObjectStorage<V>;

    beforeEach(async () => { store = await createStore(); });
    afterEach(cleanup);

    it('store() returns ObjectId and load() retrieves value', async () => { ... });
    it('load() returns undefined for non-existent id', async () => { ... });
    it('has() correctly reports existence', async () => { ... });
    it('remove() deletes stored value', async () => { ... });
    it('keys() iterates all stored ids', async () => { ... });
  });
}

// Blobs-specific tests (extends base conformance)
// packages/core/src/history/__tests__/blobs.conformance.ts
export function blobsConformanceTests(
  createBlobs: () => Promise<Blobs>,
  cleanup: () => Promise<void>
) {
  // Run base ObjectStorage tests
  objectStorageConformanceTests('Blobs', createBlobs, () => createTestBlob(), cleanup);

  // Blobs-specific tests
  describe('Blobs-specific conformance', () => {
    it('handles large blobs via streaming', async () => { ... });
    it('computes correct SHA-1 for blob ID', async () => { ... });
  });
}

// Usage in implementation tests:
// packages/core/src/backend/git-files/__tests__/git-blobs.test.ts
import { blobsConformanceTests } from '../../../history/__tests__/blobs.conformance.js';

blobsConformanceTests(
  () => createGitFilesBlobs(tempDir),
  () => cleanupTempDir()
);
```

#### Category B: Algorithm Tests (utils/)

**Purpose:** Verify pure algorithm correctness.

| Algorithm | Test File | Coverage Areas |
|-----------|-----------|----------------|
| Varint encoding | `varint.test.ts` | Encode/decode round-trip, edge cases, overflow |
| Delta parsing | `git-delta-format.test.ts` | All instruction types, malformed input |
| Delta creation | `create-delta-ranges.test.ts` | Optimal deltas, no-match cases |
| Delta application | `apply-delta.test.ts` | Correct reconstruction, error handling |
| Text diff (Myers) | `myers-diff.test.ts` | Standard cases, performance |

#### Category C: Integration Tests

**Purpose:** Verify cross-component behavior and real-world scenarios.

| Scenario | Test File | Components |
|----------|-----------|------------|
| Git clone simulation | `clone-integration.test.ts` | Transport, SerializationAPI, Stores |
| Commit round-trip | `commit-roundtrip.test.ts` | Blobs, Trees, Commits |
| Pack import/export | `pack-integration.test.ts` | SerializationAPI, GitPackStore |
| GC cycle | `gc-integration.test.ts` | DeltaApi, GCController, Stores |
| Merge workflow | `merge-integration.test.ts` | TransformationStore, ResolutionStore |
| Status calculation | `status-integration.test.ts` | Staging, Worktree, StatusCalculator |

#### Category D: Backend-Specific Tests

**Purpose:** Test backend-specific behavior and optimizations.

| Backend | Test Areas |
|---------|------------|
| Git Files | Loose object format, packed refs, pack files, index format |
| SQL | Native indexes, query performance, chunking |
| KV | Key structure, batch operations |
| Memory | State isolation, cleanup |

#### Category E: Extended Query Tests (Native Implementations)

**Purpose:** Verify extended query capabilities of native SQL/KV implementations.

| Store | Extended Tests |
|-------|----------------|
| `SqlCommits` | `findByAuthor()`, `findByDateRange()`, `searchMessage()` |
| `SqlTrees` | `findByPath()` |
| `SqlTags` | Tag listing, filtering |

### 5.3 Test Infrastructure

#### Test Fixtures

```
packages/core/src/__fixtures__/
â”œâ”€â”€ objects/
â”‚   â”œâ”€â”€ blobs/            # Sample blob contents
â”‚   â”œâ”€â”€ trees/            # Sample tree structures
â”‚   â”œâ”€â”€ commits/          # Sample commit objects
â”‚   â””â”€â”€ tags/             # Sample annotated tags
â”œâ”€â”€ packs/
â”‚   â”œâ”€â”€ small-pack.pack   # Small test pack
â”‚   â”œâ”€â”€ delta-pack.pack   # Pack with delta chains
â”‚   â””â”€â”€ large-pack.pack   # Performance testing
â””â”€â”€ repos/
    â”œâ”€â”€ simple/           # Simple test repo state
    â”œâ”€â”€ merge-conflict/   # Repo with merge conflicts
    â””â”€â”€ history/          # Repo with complex history
```

#### Test Utilities

```typescript
// packages/core/src/__tests__/utils/
export function createTempDir(): Promise<string>;
export function cleanupTempDir(dir: string): Promise<void>;
export function createMemoryBackend(): StorageBackend;
export function createTestCommit(options: Partial<Commit>): Commit;
export function createTestTree(entries: TreeEntry[]): Tree;
export function randomBlob(size: number): Uint8Array;
```

### 5.4 Migration Testing Protocol

For each migration step:

1. **Before refactoring:**
   - Ensure all existing tests pass
   - Add missing tests for functionality being refactored
   - Document baseline test count and coverage

2. **During refactoring:**
   - Run tests after each logical change
   - Add new tests for new interfaces/implementations

3. **After refactoring:**
   - All original tests must pass (or be updated if API changed)
   - New conformance tests must pass
   - No decrease in coverage percentage

### 5.5 Test Metrics

| Metric | Target |
|--------|--------|
| Interface conformance coverage | 100% of public methods |
| Algorithm test coverage | 100% of edge cases |
| Integration test scenarios | All documented workflows |
| Performance benchmarks | No regression > 10% |

### 5.6 Critical Test Paths

**Must-have tests before considering migration complete:**

1. âœ… Store conformance tests pass for all implementations
2. âœ… Git clone/push/fetch integration tests pass
3. âœ… Delta compression/decompression round-trip tests pass
4. âœ… Pack file import/export tests pass
5. âœ… Merge/rebase state persistence tests pass
6. âœ… Cross-backend compatibility tests pass (store in Git, read in SQL, etc.)

---

## Idea Categorization

### Immediate Opportunities
*Ideas ready to implement now*

1. **Centralize Varint Encoding (A1)**
   - Description: Move all varint functions to single location in utils
   - Why immediate: No dependencies, clear scope, high impact on code quality
   - Resources needed: Review existing implementations, create tests

2. **Centralize Delta Parsing (A2)**
   - Description: Refactor all delta parsing to use `parseGitDelta()` from utils
   - Why immediate: Direct redundancy removal, well-defined master implementation exists
   - Resources needed: Depends on A1 (varint)

3. **Define RawStorage Interface (B1)**
   - Description: Create clean `RawStorage` interface as backend boundary
   - Why immediate: Foundation for all subsequent refactoring
   - Resources needed: Interface design, adapter implementations

### Future Innovations
*Ideas requiring development/research*

1. **Native SQL/KV Implementations for Structured Objects**
   - Description: `SqlTrees`, `SqlCommits`, `SqlTags` with indexes
   - Development needed: Database schema design, query optimization
   - Timeline estimate: After storage abstraction foundation (Phase B complete)

2. **Extended Query Interfaces**
   - Description: `findByAuthor()`, `findByDateRange()`, `searchMessage()` for commits
   - Development needed: Index design, query interface extensions
   - Timeline estimate: After native SQL implementations

3. **TransformationStore & ResolutionStore**
   - Description: State management for merge/rebase/cherry-pick operations
   - Development needed: State machine design, conflict resolution workflow
   - Timeline estimate: Phase D (after core store migration)

### Moonshots
*Ambitious, transformative concepts*

1. **Fossil-like Query Capabilities**
   - Description: Full-text search, path-based queries, timeline views
   - Transformative potential: Moves beyond Git compatibility to enhanced VCS
   - Challenges: Maintaining Git wire protocol compatibility while adding features

2. **Hybrid Storage Strategies**
   - Description: Automatic storage backend selection based on data characteristics
   - Transformative potential: Optimal performance across different workloads
   - Challenges: Complexity of migration between backends

### Insights & Learnings
*Key realizations from the session*

- **Storage abstraction is the key boundary**: `RawStorage` interface enables all backend flexibility
- **Common base interface `ObjectStorage<V>`**: Blobs, Trees, Commits, Tags share methods (store, load, has, remove, keys) - enables generic utilities and shared conformance testing
- **Method naming matters**: Use `remove` not `delete` (JS keyword), consistent vocabulary across all interfaces
- **Random access for RawStorage**: `load(key, {start, end})` enables efficient partial reads for large files
- **Not everything needs backend-specific code**: Many components can be storage-agnostic using proper abstractions
- **Dual-path strategy for structured objects**: Git-compatible via `GitObjects` OR native SQL/KV - both paths valid
- **ChunkedRawStorage enables GitObjects on any backend**: Even SQL/KV can use git binary format if desired
- **SerializationAPI is correctly positioned**: Transport layer is truly independent through this abstraction
- **Three-part architecture is sound**: History (immutable) / Worktree (FS abstraction) / Checkout (mutable state)
- **Refs is intentionally separate**: Different semantics (atomic CAS, symbolic refs) - doesn't fit `ObjectStorage` pattern

---

## Action Planning

### Top 3 Priority Ideas

#### #1 Priority: Foundation Cleanup (Phase A)
- Rationale: Removes redundancy debt, enables cleaner subsequent work
- Next steps:
  1. Create `packages/utils/src/encoding/varint.ts`
  2. Consolidate delta parsing
  3. Add comprehensive tests
- Resources needed: Existing tests, code review
- Timeline: Can start immediately, parallel work possible

#### #2 Priority: Storage Abstraction Layer (Phase B)
- Rationale: Critical foundation for all backend flexibility
- Next steps:
  1. Define `RawStorage` interface
  2. Define `ChunkAccess` interface
  3. Implement `ChunkedRawStorage`
  4. Refactor `GitObjects` to use `RawStorage`
- Resources needed: Interface design review, backend analysis
- Timeline: After Phase A varint work (dependency)

#### #3 Priority: Store Interface Migration (Phase C)
- Rationale: Unlocks new components and public API cleanup
- Next steps:
  1. Define core store interfaces (`Blobs`, `Trees`, `Commits`, `Tags`)
  2. Implement storage-agnostic versions
  3. Create `History` facade
  4. Consolidate store wrappers
- Resources needed: Current store analysis, test migration
- Timeline: After Phase B (dependency)

---

## Reflection & Follow-up

### What Worked Well
- Progressive flow approach (broad â†’ narrow â†’ converge)
- Codebase exploration to find concrete redundancies
- Layered architecture analysis
- Dual-path strategy discovery for SQL/KV backends

### Areas for Further Exploration
- Performance benchmarking: Need baseline metrics before migration
- SQL schema design: Optimal table structures for Trees/Commits/Tags
- Extended query interfaces: Exact API surface for Fossil-like features

### Recommended Follow-up Techniques
- **Spike exploration**: Prototype `ChunkedRawStorage` to validate design
- **Schema design session**: Focus on SQL table structures for native implementations
- **API review session**: Review extended query interface designs with potential consumers

### Questions That Emerged
- How to handle migration of existing repositories between backends?
- What's the performance trade-off between git-format and native SQL storage?
- Should extended query interfaces be optional or required for all implementations?

### Next Session Planning
- **Suggested topics:** SQL schema design for native implementations, performance benchmarking strategy
- **Recommended timeframe:** After Phase A completion
- **Preparation needed:** Review existing SQL abstraction layer, identify benchmark scenarios

---

*Session facilitated using the BMAD-METHOD brainstorming framework*
